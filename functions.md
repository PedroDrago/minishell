# Functions
- `readline(const char *prompt)`: Literalmente mostra o prompt e lê o que o usuario digita, e retorna isso como uma string. (tem que adicionar `-lreadline` na compilação)
- `rl_clear_history()`: ?
- `rl_on_new_line()`: ?
- `rl_replace_line(const char *text, int clear_undo)`: ?
- `rl_redisplay()`: ?
- `add_history(const char *string)`: ?
- `access(const char *name, int type)`: ?
- `open(const char *file, int oflag, ...)`: ?
- `fork()`: ?
- `wait(int *stat_loc)`: ?
- `wait3(int *stat_loc, int options, struct rusage *usage)`: ?
- `wait4(__pid_t pid, int *stat_loc, int options, struct rusage *usage)`: ?
- `waitpid(__pid_t pid, int *stat_loc, int options)`: ?
- `sigemptyset(sigset_t *set)`: ?
- `sigaddset(sigset_t *set, int signo)`: ?
- `getcwd(char *buf, size_t size)`: Pega o path atual que o programa ta rodando, tipo rodar um `pwd`. A função guarda o path no `buffer` que tem tamanho `size`.Buff e size são argumentos semelhantes aos de `read()`.
- `chdir(const char *path)`: Semelhante a um `cd`, na real é igual, a gente passa um path (absoluto ou relativo) e o programa passa a estar rodando nesse path.
- `stat(const char *restrict file, struct stat *restrict buf)`: ?
- `lstat(const char *restrict file, struct stat *restrict buf)`: ?
- `fstat(int fd, struct stat *buf)`: ?
- `unlink(const char *name)`: ?
- `execve(const char *path, char *const *argv, char *const *envp)`: ?
- `dup(int fd)`: ?
- `dup2(int fd, int fd2)`: ?
- `pipe(int *pipedes)`: ?
- `isatty(int fd)`: ?
- `ttyname(int fd)`: ?
- `ttyslot()`: ?
- `ioctl(int fd, unsigned long request, ...)`: ?
- `getenv(const char *name)`: ?
- `tcsetattr(int fd, int optional_actions, const struct termios *termios_p)`: ?
- `tcgetattr(int fd, struct termios *termios_p)`: ?
- `tgetent(char *bp, const char *name)`: ?
- `tgetflag(const char *id)`: ?
- `tgetnum(const char *id)`: ?
- `tgetstr(const char *id, char **area)`: ?
- `tgoto(const char *cap, int col, int row)`: ?
- `tputs(const char *str, int affcnt, int (*putc)(int))`: ?
